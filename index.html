<!DOCTYPE html>
<meta charset="utf-8">
<style>

 svg {
	border: 1px dotted black;
  float:left
  
 }
 svg.busy {
     background: rgba(255,0,0,0.03);
 }
.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

#licensing {
  fill: green;
}

.link.no_mst {
  stroke: #cc0000;
}
.link.mst {
  stroke: #00ff00;
}

.link.resolved {
  stroke-dasharray: 0,2 1;
}

circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}
circle.selected {
  fill: green;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}
input {
  float:left;
}
textarea {
  float:left;
  height:476px;
    margin-left: -173px;
    margin-top: 20px;  
}
g.circle {
  z-index:9;
}
</style>
<body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<pre>Left click on empty area to add new edge to graph</pre>
<script>
var mst_in_progress = false;
function dist( a, b )
{
	return ((a - b) % 2) ? 60 : 120;
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return dx*dx + dy*dy;
}

var selectedNode = -1;
var N = 0;
var MST = [];
var width = 960,
    height = 500;
var delay = 1000;
var force = d3.layout.force()
//    .nodes(nodes)
//    .links(links)
    .size([width, height])
//    .linkDistance(60)
    .gravity(0.1)
    .charge(-600)
    .on("tick", tick)
    .linkDistance(function(link){
      //return 60;
      var s=link.source, t= link.target;
	  return dist( parseInt(s.name), parseInt(t.name) )
      //return Math.sqrt(Math.pow(s.x0 - t.x0,2) + Math.pow(s.y0 - t.y0,2));
    })
    .start();

var nodes = force.nodes();
var links = force.links();
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
	.on("click", function(){
		var addNode1 = true;
		var addNode2 = true;
    var skipLink = false;
		d3.event.preventDefault();
		d3.event.stopPropagation();
		if(mst_in_progress) return false;
    
    var s = 0;
    var t = 1;
		
		if(N > 1) {
      s = Math.floor(Math.random() * N*2);
      do {
        t = Math.floor(Math.random() * N*2);
      } while(s == t);
    }
    var ss = s + 1;
    var tt = t + 1;
		for (var ind in nodes) { // check if node with same name exists
      if(nodes[ind].name == ss) { s = parseInt(ind); addNode1 = false};
      if(nodes[ind].name == tt) { t = parseInt(ind); addNode2 = false};
    }
		for (var ind in links) {
			if (links[ind].source.n == s && links[ind].target.n == t) skipLink = true;
			if (links[ind].source.n == t && links[ind].target.n == s) skipLink = true;
		}
		if (addNode1) s = addNode(ss);
		if (addNode2) t = addNode(tt);
      
		if(!skipLink){
			link = addLink(s,t);
      fixCycle(t, s, link);
    }
		return false;
		
	});

// Per-type markers, as they don't inherit styles.
svg.append("defs").selectAll("marker")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5");

  var textarea = d3.select("body").append("input").on("keyup", function(e){
    if(d3.event.which == 13) {
      var edge = this.value.split(/[,\/ -]/);
      if(edge.length==2) {
        edge[0] = parseInt(edge[0]);
        edge[1] = parseInt(edge[1]);
        if (edge[0] == edge[1]) return;
        var found1 = -1;
        var found2 = -1;
        for(var ind in nodes) {
          if(nodes[ind].name == edge[0]) found1 = parseInt(ind);
          if(nodes[ind].name == edge[1]) found2 = parseInt(ind);
        }
        if( found1 >=0 && found2 >=0) {
        		for (var ind in links) {
              if (links[ind].source.n == found1 && links[ind].target.n == found2) return;
              if (links[ind].source.n == found2 && links[ind].target.n == found1) return;
            }
        }
        if (found1 < 0) {
          found1 =addNode(edge[0]);
        }
        if (found2 <0) {
          found2 = parseInt(addNode(edge[1]));
        }        
        link = addLink(found1, found2);
        fixCycle(found2, found1, link);
        this.value = '';
      }
    }
  }).attr("placeholder", "Add edge: ex: 10 - 43 ");
  var textarea = d3.select("body").append("textarea");
	

// Use elliptical arc path segments to doubly-encode directionality.
function tick() {
  //svg.selectAll("g > path").attr("d", linkArc);
  svg.selectAll("g > line").attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
        .attr("class", function(d) { return "link " + (d.mst == 1 ? 'mst' : (d.mst == 0 ? 'no_mst': '')); });
  svg.selectAll("g > circle").attr("transform", transform).attr("class", function(d) { return d.n == selectedNode ? 'selected' : ''; });
  svg.selectAll("g > text").attr("transform", transform);
   
  //circle.attr("transform", transform);
  //text.attr("transform", transform);
}

function linkArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy);
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}


function transform(d) {
  return "translate(" + d.x + "," + d.y + ")";
}

function addNode(name){
    if(mst_in_progress) return false;
  if(name == undefined) name = N+1;
  console.log(d3.event);
	var node = {};
  if (d3.event.type == "click" )
    node = {name: name, n:N, x:d3.event.offsetX, y:d3.event.offsetY};
  else
    node = {name: name, n:N};
    
	nodes.push(node);
	svg.append("g").attr("class","circle").selectAll("circle")
      .data([node])
      .enter().append("circle")
	  .attr("r", 8)
      .call(force.drag)
	  
	  .on("click", function(d) {
	  	d3.event.stopPropagation();
      if(selectedNode == -1) {
        selectedNode = d.n;
      } else if (selectedNode == d.n) {
        selectedNode = -1;
      } else {
        link = addLink(selectedNode, d.n);
        fixCycle(d.n, selectedNode, link);
        //addLink(d.n,selectedNode);
        selectedNode = -1;
      }
      d3.event.stopPropagation();
	  });
	  
	svg.append("g").selectAll("text")
		.data([node])
		.enter().append("text")
		.attr("x", 10)
		.attr("y", ".31em")
		.text(function(d) { return d.name; });	  
    /*
    if(N > 0) {
      var s = N;
      var t = Math.floor((Math.random() * N));
      link = addLink(s, t);
      link.mst = 1;
      //MST.push(link);
      fixCycle(t, s, link)
    }
    */
	N++;
	delay = (1000 / N)*2;
	force.start();
  return node.n;
}

function addLink(s, t) {
	//console.log(s,t, d3.select("textarea")[0][0].value );
  var ss = nodes[s].name;
  d3.select("textarea")[0][0].value = nodes[s].name + " - " + nodes[t].name + "\n" + d3.select("textarea")[0][0].value;
	link = {source: s, target: t, weight: dist( parseInt(nodes[s].name), parseInt(nodes[t].name) )};
	links.push(link);
//	svg.append("g").selectAll("path")
	svg.append("g").selectAll("line")
    .data([link])
	.enter().append("line")
    .attr("class", function(d) { return "link " + (d.mst ? 'mst' : ''); })
//    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });
	force.start();
  return link;
  //mst_kruskal();
}

function findEdgeInMST(s) {
  for (ind in MST) {
    if (MST[ind].source.n == s && !MST[ind].visited) { MST[ind].visited = true; return [MST[ind], MST[ind].target.n, ind]; }
    if (MST[ind].target.n == s && !MST[ind].visited) { MST[ind].visited = true; return [MST[ind], MST[ind].source.n, ind]; }
  }
  return [-1, -1];
}
function traversePath(v, t, path) {
  if(t == v) return path;
  while(true) {
    var edge = findEdgeInMST(v);
    if(edge[0] == -1) return -1;
    var new_path = traversePath(edge[1], t, path.concat([ edge ]));
    if(new_path !== -1) return new_path;
  }
  return -1;
}
function fixCycle(s, t, link) {
  console.log(s, t, MST);
  for (ind in MST) {
      MST[ind].visited = false;
  }
  path = traversePath(s, t, []);
  if(path === -1 || path.length == 0) {
    link.mst = true;
    MST.push(link);
    tick();
    return;
  }
  path.sort( function(a, b) { return a[0].weight - b[0].weight; } );
  console.log(path);
  if(path[path.length-1][0].weight > link.weight) {
    path[path.length-1][0].mst = false;
    MST.splice(path[path.length-1][2], 1);
    link.mst = true;
    MST.push(link);
    tick();
  }
}

function MakeSet(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
  this.find = function(x) {
    var x0 = x
    var roots = this.roots;
    while(roots[x] !== x) {
      x = roots[x]
    }
    while(roots[x0] !== x) {
      var y = roots[x0]
      roots[x0] = x
      x0 = y
    }
    return x;
  }

  
  this.link = function(x, y) {
    var xr = this.find(x)
      , yr = this.find(y);
    if(xr === yr) {
      return;
    }
    var ranks = this.ranks
      , roots = this.roots
      , xd    = ranks[xr]
      , yd    = ranks[yr];
    if(xd < yd) {
      roots[xr] = yr;
    } else if(yd < xd) {
      roots[yr] = xr;
    } else {
      roots[yr] = xr;
      ++ranks[xr];
    }
  }
}
function mst_kruskal_step(edgeDist, forest, finalEdge, i) {
	var u = edgeDist[i].edge.source.index;
	var v = edgeDist[i].edge.target.index;

	// Coloring step (Kruskal). If the current edge e has both ends in the same blue
	// tree, color it red; otherwise color it blue.
	if ( forest.find(u) != forest.find(v) )
	{
	  finalEdge.push( [ u, v ] );
	  forest.link( u, v );
	  edgeDist[i].edge.mst = 1;
	} else {
	  edgeDist[i].edge.mst = 0;
	}
	tick();
	if(i < edgeDist.length-1) {
		setTimeout(function(){
			mst_step(edgeDist, forest, finalEdge, i+1);
		}, delay)
	} else {
		mst_in_progress = false;
		svg.attr("class", "");
	}
	
}

function mst_kruskal() {
	  mst_in_progress = true;
	  svg.attr("class", "busy");	  
      var set = {};

      var finalEdge = [];

      var edgeDist = [];
      for (var ind in links)
      {
        links[ind].mst = -1;
        var u = links[ind].source;
        var v = links[ind].target;
        var e = { edge: links[ind], weight: dist( u.n, v.n )  };
        edgeDist.push(e);
      }
	  tick();
	  /*
		To implement Kruskal's algorithm, we must solve two problems: ordering the
		edges by cost and representing the blue trees so that we can test whether two vertices
		in the blue The simplest solve the former problem is the
		edges by cost in a preprocessing step. The latter problem is a version of the disjoint
		set union problem discussed in Chapter 2, and we can use the operations of makeset,
		find and link to maintain the vertex sets of the blue trees.
	 */
      var forest = new MakeSet( nodes.length );
      edgeDist.sort( function(a, b) { return a.weight- b.weight; } );
      var i = 0;
      setTimeout(function(){
        mst_kruskal_step(edgeDist, forest, finalEdge, i);
      }, delay)
      return;
	  
      for (var i=0; i<edgeDist.length; i++)
      {
        mst_kruskal_step(edgeDist, forest, finalEdge, i);
      }
      
      for (var ind in finalEdge)
      {
        var u = finalEdge[ind][0];
        var v = finalEdge[ind][1];

        console.log( nodes[u].name + " - " + nodes[v].name );

      }
        console.log("");

      return finalEdge;

}

</script>
<a href="https://github.com/andresviikmaa/Streaming-Minimum-Spanning-Tree" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>   