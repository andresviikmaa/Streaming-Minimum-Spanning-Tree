<!DOCTYPE html>
<meta charset="utf-8">
<style>

 svg {
	border: 1px dotted black;
 }
 svg.busy {
     background: rgba(255,0,0,0.03);
 }
.link {
  fill: none;
  stroke: #666;
  stroke-width: 1.5px;
}

#licensing {
  fill: green;
}

.link.no_mst {
  stroke: #cc0000;
}
.link.mst {
  stroke: #00ff00;
}

.link.resolved {
  stroke-dasharray: 0,2 1;
}

circle {
  fill: #ccc;
  stroke: #333;
  stroke-width: 1.5px;
}
circle.selected {
  fill: green;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<pre>Left click on empty area to create node with link to random node <br>or right click to create link between two random nodes</pre>
<script>
var mst_in_progress = false;
function dist( a, b )
{
	return ((a.n - b.n) % 2) ? 60 : 120;
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return dx*dx + dy*dy;
}

var selectedNode = -1;
var N = 0;

var width = 960,
    height = 500;
var delay = 1000;
var force = d3.layout.force()
//    .nodes(nodes)
//    .links(links)
    .size([width, height])
//    .linkDistance(60)
    .gravity(0.01)
    .charge(-300)
    .on("tick", tick)
    .linkDistance(function(link){
      //return 60;
      var s=link.source, t= link.target;
	  return dist( s, t )
      //return Math.sqrt(Math.pow(s.x0 - t.x0,2) + Math.pow(s.y0 - t.y0,2));
    })
    .start();

var nodes = force.nodes();
var links = force.links();
	
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
	.on("click", function(){
		var _addNode = false;
		d3.event.preventDefault();
		d3.event.stopPropagation();
		if(mst_in_progress) return false;
		if(N < 2) {
			addNode();
			return false;
		}
		
		var s = Math.floor(Math.random() * N);
		var t = Math.floor(Math.random() * N);
		for (var ind in links) {
			if (s == t) _addNode = true;
			if (links[ind].source.n == s && links[ind].target.n == t) _addNode = true;
			if (links[ind].source.n == t && links[ind].target.n == s) _addNode = true;
		}
		if (_addNode)
			addNode();
		else
			addLink(s,t);
		return false;
		
	});

// Per-type markers, as they don't inherit styles.
svg.append("defs").selectAll("marker")
    .data(["suit", "licensing", "resolved"])
  .enter().append("marker")
    .attr("id", function(d) { return d; })
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M0,-5L10,0L0,5");

// Use elliptical arc path segments to doubly-encode directionality.
function tick() {
  //svg.selectAll("g > path").attr("d", linkArc);
  svg.selectAll("g > line").attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
        .attr("class", function(d) { return "link " + (d.mst == 1 ? 'mst' : (d.mst == 0 ? 'no_mst': '')); });
  svg.selectAll("g > circle").attr("transform", transform).attr("class", function(d) { return d.n == selectedNode ? 'selected' : ''; });
  svg.selectAll("g > text").attr("transform", transform);
   
  //circle.attr("transform", transform);
  //text.attr("transform", transform);
}

function linkArc(d) {
  var dx = d.target.x - d.source.x,
      dy = d.target.y - d.source.y,
      dr = Math.sqrt(dx * dx + dy * dy);
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}


function transform(d) {
  return "translate(" + d.x + "," + d.y + ")";
}

function addNode(){
    if(mst_in_progress) return false;


	var node = {name: N+1, n:N, x:d3.event.offsetX, y:d3.event.offsetY , x0:d3.event.offsetX, y0:d3.event.offsetY};
	nodes.push(node);
	svg.append("g").selectAll("circle")
      .data([node])
      .enter().append("circle")
	  .attr("r", 8)
      .call(force.drag)
	  
	  .on("click", function(d) {
	  	d3.event.stopPropagation();
		return false;
		/*
      if(selectedNode == -1) {
        selectedNode = d.n;
      } else if (selectedNode == d.n) {
        selectedNode = -1;
      } else {
        addLink(selectedNode, d.n);
        //addLink(d.n,selectedNode);
        selectedNode = -1;
      }
      d3.event.stopPropagation();
	  */});
	  
	svg.append("g").selectAll("text")
		.data([node])
		.enter().append("text")
		.attr("x", 10)
		.attr("y", ".31em")
		.text(function(d) { return d.name; });	  
	if(N > 0)
		addLink(N, Math.floor((Math.random() * N)));
	N++;
	delay = (1000 / N)*2;
	force.start();
}

function addLink(s, t) {
	console.log(s,t);
	link = {source: s, target: t, type: "suit"};
	links.push(link);
//	svg.append("g").selectAll("path")
	svg.append("g").selectAll("line")
    .data([link])
	.enter().append("line")
    .attr("class", function(d) { return "link " + (d.mst ? 'mst' : ''); })
//    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });
	force.start();
  mst();
}
function MakeSet(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
  this.find = function(x) {
    var x0 = x
    var roots = this.roots;
    while(roots[x] !== x) {
      x = roots[x]
    }
    while(roots[x0] !== x) {
      var y = roots[x0]
      roots[x0] = x
      x0 = y
    }
    return x;
  }

  
  this.link = function(x, y) {
    var xr = this.find(x)
      , yr = this.find(y);
    if(xr === yr) {
      return;
    }
    var ranks = this.ranks
      , roots = this.roots
      , xd    = ranks[xr]
      , yd    = ranks[yr];
    if(xd < yd) {
      roots[xr] = yr;
    } else if(yd < xd) {
      roots[yr] = xr;
    } else {
      roots[yr] = xr;
      ++ranks[xr];
    }
  }
}
function mst_step(edgeDist, forest, finalEdge, i) {
	var u = edgeDist[i].edge.source.index;
	var v = edgeDist[i].edge.target.index;

	// Coloring step (Kruskal). If the current edge e has both ends in the same blue
	// tree, color it red; otherwise color it blue.
	if ( forest.find(u) != forest.find(v) )
	{
	  finalEdge.push( [ u, v ] );
	  forest.link( u, v );
	  edgeDist[i].edge.mst = 1;
	} else {
	  edgeDist[i].edge.mst = 0;
	}
	tick();
	if(i < edgeDist.length-1) {
		setTimeout(function(){
			mst_step(edgeDist, forest, finalEdge, i+1);
		}, delay)
	} else {
		mst_in_progress = false;
		svg.attr("class", "");
	}
	
}

function mst() {
	  mst_in_progress = true;
	  svg.attr("class", "busy");	  
      var set = {};

      var finalEdge = [];

      var edgeDist = [];
      for (var ind in links)
      {
		links[ind].mst = -1;
        var u = links[ind].source;
        var v = links[ind].target;
        var e = { edge: links[ind], weight: dist( u, v )  };
        edgeDist.push(e);
      }
	  tick();
	  /*
		To implement Kruskal's algorithm, we must solve two problems: ordering the
		edges by cost and representing the blue trees so that we can test whether two vertices
		in the blue The simplest solve the former problem is the
		edges by cost in a preprocessing step. The latter problem is a version of the disjoint
		set union problem discussed in Chapter 2, and we can use the operations of makeset,
		find and link to maintain the vertex sets of the blue trees.
	 */
      var forest = new MakeSet( nodes.length );
      edgeDist.sort( function(a, b) { return a.weight- b.weight; } );
	  var i = 0;
		setTimeout(function(){
			mst_step(edgeDist, forest, finalEdge, i);
		}, delay)
	  return;
	  
      for (var i=0; i<edgeDist.length; i++)
      {
		mst_step(edgeDist, forest, finalEdge, i);
      }
      
      for (var ind in finalEdge)
      {
        var u = finalEdge[ind][0];
        var v = finalEdge[ind][1];

        console.log( nodes[u].name + " - " + nodes[v].name );

      }
        console.log("");

      return finalEdge;

}

</script>
<a href="https://github.com/andresviikmaa/Streaming-Minimum-Spanning-Tree" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>   